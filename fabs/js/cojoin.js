/**
 * fabs/js/cojoin.js
 *
 * This script contains the logic for both the Contact Us and Join Us forms.
 * It handles form submission, security checks (honeypot, malicious code),
 * and the dynamic form fields for the Join form.
 */

function initCojoinForms() {
  const contactForm = document.getElementById('contactForm');
  const joinForm = document.getElementById('joinForm');

  window.antibot.loadRecaptcha();

  if (contactForm && !contactForm.dataset.cojoinInitialized) {
    window.antibot.injectFormHoneypot(contactForm);
    contactForm.addEventListener('submit', handleContactSubmit);
    contactForm.dataset.cojoinInitialized = 'true';
  }

  if (joinForm && !joinForm.dataset.cojoinInitialized) {
    window.antibot.injectFormHoneypot(joinForm);
    joinForm.addEventListener('submit', handleJoinSubmit);
    joinForm.dataset.cojoinInitialized = 'true';
    initJoinForm();
  }


  /**
   * Retrieves an AES-GCM key generated by a server-side KMS/HSM.
   * The server is responsible for managing the lifecycle of this key
   * in alignment with NIST and PCI DSS requirements.
   * @returns {Promise<CryptoKey>} The imported AES-GCM key.
   */
  async function getAesKeyFromKms() {
    // ====================================================================================
    // IMPORTANT: AES Key Service Endpoint
    // Replace the URL below with your actual endpoint for fetching the AES key.
    // ====================================================================================
    const res = await fetch('https://your-server.opsonlinessupport.com/kms/aes-key');
    const { key } = await res.json(); // base64 encoded key material
    const rawKey = base64ToArrayBuffer(key);
    return crypto.subtle.importKey('raw', rawKey, { name: 'AES-GCM' }, false, ['encrypt']);
  }

  /**
   * Requests a short-lived bearer token from the server. The token is
   * returned as an AES-GCM encrypted blob alongside its IV so it can be
   * decrypted by the Cloudflare worker.
   * @returns {Promise<{token: string, iv: string}>}
   */
  async function getBearerToken() {
    // ====================================================================================
    // IMPORTANT: Auth Token Service Endpoint
    // Replace the URL below with your actual endpoint for fetching the auth token.
    // ====================================================================================
    const res = await fetch('https://your-server.opsonlinessupport.com/auth/token');
    return res.json(); // { token: base64CipherText, iv: base64IV }
  }

  function arrayBufferToBase64(buffer) {
    return btoa(String.fromCharCode(...new Uint8Array(buffer)));
  }

  function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }

  /**
   * Simulated function to send data to a Cloudflare worker.
   * This is where you would implement your data encryption logic before sending.
   * @param {object} data The sanitized form data to send.
   */
  async function sendToCloudflareWorker(data) {
    console.log("Data is clean. Encrypting and sending to Cloudflare worker...", data);
    try {
      // Retrieve managed key and short-lived token from the server
      const [aesKey, tokenInfo] = await Promise.all([
        getAesKeyFromKms(),
        getBearerToken(),
      ]);

      // Encrypt payload using AES-GCM
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encoder = new TextEncoder();
      const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv },
        aesKey,
        encoder.encode(JSON.stringify(data))
      );

      const payload = {
        iv: Array.from(iv),
        payload: arrayBufferToBase64(encrypted),
      };

      // Compose Authorization header as Bearer <iv>.<cipher>
      const authHeader = `Bearer ${tokenInfo.iv}.${tokenInfo.token}`;

      // ====================================================================================
      // IMPORTANT: Cloudflare Worker API Endpoint
      // Replace the URL below with your actual Cloudflare Worker API endpoint.
      // ====================================================================================
      const response = await fetch('https://recaptcha-botforms.gabrieloor-cv1.workers.dev/api', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': authHeader,
        },
        body: JSON.stringify(payload),
      });

      if (response.ok) {
        console.log('Data successfully sent and processed by Cloudflare worker.');
      } else {
        console.error('Failed to send data to Cloudflare worker.');
      }
    } catch (error) {
      console.error('Network error or worker unreachable:', error);
    }
  }

  /**
   * Contact Us form submission handler.
   * @param {Event} e The form submission event.
   */
  async function handleContactSubmit(e) {
    e.preventDefault();

    const form = e.target;
    // 1. Honeypot check
    if (window.antibot.isHoneypotTriggered(form)) {
      console.warn('Honeypot filled. Blocking form submission.');
      form.reset();
      return;
    }
    const formData = new FormData(form);

    const data = Object.fromEntries(formData.entries());

    // 2. Malicious code check and sanitization
    const sanitizedData = {};
    for (const key in data) {
      const sanitizedValue = window.appUtils.sanitizeInput(data[key]);
      sanitizedData[key] = sanitizedValue;
    }

    // Obtain reCAPTCHA token
    try {
      sanitizedData.recaptchaToken = await window.antibot.getRecaptchaToken('contact');
    } catch (err) {
      alert('Security check failed.');
      return;
    }

    // 3. Prepare and send sanitized data to worker
    alert('Contact form submitted successfully!');
    await sendToCloudflareWorker(sanitizedData);
    form.reset();
    if (window.hideActiveFabModal) {
      window.hideActiveFabModal();
    }
  }

  /**
   * Join Us form submission handler.
   * @param {Event} e The form submission event.
   */
  async function handleJoinSubmit(e) {
    e.preventDefault();

    const form = e.target;
    // 1. Honeypot check
    if (window.antibot.isHoneypotTriggered(form)) {
      console.warn('Honeypot filled. Blocking form submission.');
      form.reset();
      return;
    }
    const formData = new FormData(form);

    const data = Object.fromEntries(formData.entries());

    // Check that all dynamic sections are 'accepted' or empty
    const formSections = document.querySelectorAll('.form-section[data-section]');
    for (const section of formSections) {
      const inputs = section.querySelectorAll('input[type=text]');
      if (inputs.length > 0 && !section.classList.contains('completed')) {
        alert(`Please accept your entries in "${section.querySelector('h2').textContent}" or remove them.`);
        return;
      }
    }

    // 2. Malicious code check and sanitization
    const sanitizedData = {};
    for (const key in data) {
      const sanitizedValue = window.appUtils.sanitizeInput(data[key]);
      sanitizedData[key] = sanitizedValue;
    }

    // Obtain reCAPTCHA token
    try {
      sanitizedData.recaptchaToken = await window.antibot.getRecaptchaToken('join');
    } catch (err) {
      alert('Security check failed.');
      return;
    }

    // 3. Prepare and send sanitized data to worker
    alert('Join form submitted successfully!');
    await sendToCloudflareWorker(sanitizedData);
    form.reset();
    resetJoinFormState();
    if (window.hideActiveFabModal) {
      window.hideActiveFabModal();
    }
  }

  /**
   * Initializes event listeners for the Join Us form's dynamic sections.
   */
  function initJoinForm() {
    const formSections = document.querySelectorAll('.form-section[data-section]');
    formSections.forEach(section => {
      const addBtn = section.querySelector('.circle-btn.add');
      const removeBtn = section.querySelector('.circle-btn.remove');
      const acceptBtn = section.querySelector('.accept-btn');
      const editBtn = section.querySelector('.edit-btn');
      const inputsContainer = section.querySelector('.inputs');

      if (addBtn) {
        addBtn.addEventListener('click', () => {
          let field;
          if (section.dataset.section === 'Experience') {
            const count = inputsContainer.querySelectorAll('textarea').length + 1;
            field = document.createElement('textarea');
            field.rows = 3;
            field.placeholder = `tell us about your Experience ${count}`;
          } else if (section.dataset.section === 'Continued Education') {
            field = document.createElement('textarea');
            field.rows = 3;
            field.placeholder = 'Online Courses, Seminars, Webinars with Completion Certification';
          } else {
            field = document.createElement('input');
            field.type = 'text';
            field.placeholder = `Enter ${section.querySelector('h2').textContent.toLowerCase()}`;
          }
          inputsContainer.appendChild(field);
          field.focus();
        });
      }

      if (removeBtn) {
        removeBtn.addEventListener('click', () => {
          if (!section.classList.contains('completed')) {
            if (inputsContainer.lastElementChild) {
              inputsContainer.removeChild(inputsContainer.lastElementChild);
            }
          }
        });
      }

      if (acceptBtn) {
        acceptBtn.addEventListener('click', () => {
          const inputs = inputsContainer.querySelectorAll('input[type=text], textarea');
          if (inputs.length === 0) {
            alert('Add at least one entry.');
            return;
          }
          for (const input of inputs) {
            if (!input.value.trim()) {
              alert('Please fill out all fields before accepting.');
              return;
            }
          }
          toggleSectionState(section, true);
        });
      }

      if (editBtn) {
        editBtn.addEventListener('click', () => {
          toggleSectionState(section, false);
        });
      }
    });
  }

  /**
   * Resets the Join Us form to its initial state after submission.
   */
  function resetJoinFormState() {
    const formSections = document.querySelectorAll('.form-section[data-section]');
    formSections.forEach(section => {
      toggleSectionState(section, false);
      const inputsContainer = section.querySelector('.inputs');
      inputsContainer.innerHTML = '';
    });
  }

  /**
   * Toggles the state of a dynamic form section (accepted/editable).
   * @param {HTMLElement} section The form section element.
   * @param {boolean} accepted True to lock the section, false to unlock.
   */
  function toggleSectionState(section, accepted) {
    const inputs = section.querySelectorAll('input[type=text], textarea');
    const acceptBtn = section.querySelector('.accept-btn');
    const editBtn = section.querySelector('.edit-btn');
    const addBtn = section.querySelector('.circle-btn.add');
    const removeBtn = section.querySelector('.circle-btn.remove');

    inputs.forEach(input => input.disabled = accepted);

    if (accepted) {
      if (acceptBtn) acceptBtn.style.display = 'none';
      if (editBtn) editBtn.style.display = 'inline-block';
      if (addBtn) addBtn.disabled = true;
      if (removeBtn) removeBtn.disabled = true;
      section.classList.add('completed');
    } else {
      if (acceptBtn) acceptBtn.style.display = 'inline-block';
      if (editBtn) editBtn.style.display = 'none';
      if (addBtn) addBtn.disabled = false;
      if (removeBtn) removeBtn.disabled = false;
      section.classList.remove('completed');
    }
  }
}

window.initCojoinForms = initCojoinForms;
document.addEventListener('DOMContentLoaded', initCojoinForms);
